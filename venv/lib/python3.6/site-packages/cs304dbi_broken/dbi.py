'''Module to read MySQL database credentials and access databases as the
MySQL user.

This module is designed to work with the pymysql package and make it
easier to read the database credentials from the standard ~/.my.cnf file,
or any file of similar format.  Doing so avoids putting those credentials
in the source code and removes that dependency from the code.

The format is a file of key = value pairs where the keys are host, user,
password and, optionally, database

Defines a read_cnf() function to return a dictionary with the MySQL
database credentials.

Also defines a function to replace the pymysql.connect function using a
dictionary of database credentials, as returned by the read_cnf()
function. That database connection is set to auto_commit().

In this module, DSN stands for "Data Source Name"

How to use this:

import dbi

Use one of the following to read the credentials (DSN) file

dsn = dbi.read_cnf()
dsn = dbi.read_cnf('~/.my.cnf')
dsn = dbi.read_cnf('/path/to/any/dsn_file')

Even better, use dbi.read_cnf_once() which caches the result in a global
variable.

Your credentials file may specify a database to connect to. You can
optionally assign or modify that value or use the select_db() method
on the connection.

dsn['db'] = 'wmdb'     # the database we want to connect to

Use the DSN (credentials dictionary) to connect to the database. From here
on, mostly use the PyMySQL API.

conn = dbi.connect(dsn)
conn.select_db('wmdb')
curs = db.dictCursor(conn)
curs.execute('select name,birthdate from person')
curs.execute('select name,birthdate from person where name like %s',
             ['%george%'])
curs.fetchall()
curs.fetchone()

TODO:

This is really too thin an interface. Exceptions thrown by .execute() and
such will be pymysql exceptions, not cs304dbi exceptions. Ideally, rewrite
this with classes for Connections, Cursors, and Exceptions. But that's a
lot of work for little benefit.

Scott D. Anderson
Fall 2019 latest revision
'''

import pymysql
import re
import os

def file_contents(filename):
    '''Returns contents of file as a string.'''
    with open(filename,"r") as infile:
        return infile.read()

def read_cnf(cnf_file=None):
    '''Read a file formatted like ~/.my.cnf file; defaulting to that
    file. Return a dictionary with the necessary information to connect to
    a database. See the connect() function.'''
    if cnf_file is None:
        cnf_file = os.path.expanduser('~/.my.cnf')
    else:
        cnf_file = os.path.expanduser(cnf_file)
    cnf = file_contents(cnf_file)
    credentials = {}
    # the key is the name used in the CNF file;
    # the value is the name used in the MySQLdb.connect() function
    mapping = {'host':'host',
               'user':'user',
               'password':'passwd',
               'database':'db'}
    for key in ('host', 'user', 'password', 'database' ):
        cred_key = mapping[key]
        regex = r"\b{k}\s*=\s*[\'\"]?(\w+)[\'\"]?\b".format(k=key)
        # print 'regex',regex
        p = re.compile(regex)
        m = p.search(cnf)
        if m:
            credentials[ cred_key ] = m.group(1)
        elif key == 'host' or key == 'database':
            credentials[ cred_key ] = 'not specified in ' + cnf_file
        else:
            raise Exception('Could not find key {k} in {f}'
                            .format(k=key,f=cnf_file))
    return credentials

DSN = None

def read_cnf_once(cnf_file=None):
    '''Like the read_cnf function, but caches the result in a global. To
re-read the cnf_file and overwrite the cache, use read_cnf_again()'''
    global DSN
    if DSN is None:
        DSN = read_cnf(cnf_file)
    return DSN

def read_cnf_again(cnf_file=None):
    '''Re-reads the CNF file and overwrites the cache that is used by
read_cnf_once.'''
    global DSN
    DSN = read_cnf(cnf_file)
    return DSN

def checkDSN(dsn):
    '''Raises a comprehensible error message if the DSN is missing
some necessary info, say because the CNF file is incomplete.'''
    for key in ('host', 'user', 'passwd', 'db' ):
        if not key in dsn:
            raise KeyError('''DSN lacks necessary '{k}' key'''.format(k=key))
    return True

def connect(dsn):
    '''Returns a new database connection given the dsn (a dictionary)

    The database connection is set to automatically commit.'''
    checkDSN(dsn)
    try:
        # I have no idea why this unix_socket thing is necessary, and 
        # only for deployed apps, but not in development mode
        # see stackoverflow.com/questions/6885164/
        # pymysql-cant-connect-to-mysql-on-localhost
        conn = pymysql.connect( use_unicode=True,
                                charset='utf8',
                                unix_socket='/var/lib/mysql/mysql.sock',
                                **dsn )
        # so each modification takes effect automatically
        conn.autocommit(True)
    except pymysql.Error as e:
        print("Couldn't connect to database. PyMySQL error {}: {}"
              .format(e.args[0], e.args[1]))
        raise
    return conn

def select_db(conn,db):
    '''This function isn't necessary; just use the select_db() method
    on the connection'''
    conn.select_db(db)

def connect_again(cnf_file, db=None):
    '''reads the cnf file with read_cnf_once() and connects using the cached
DSN, returning the connection. If supplied, connects to the db.'''
    read_cnf_once(cnf_file)
    conn = connect(DSN)
    if db:
        select_db(conn,db)
    return conn

# function synonym. Which name will be more popular?
reconnect = connect_again

def cursor(conn):
    '''Returns a cursor where rows are represented as tuples.'''
    return conn.cursor()

# this function name should use snake_case rather than camelCase
def dictCursor(conn):
    '''Returns a cursor where rows are represented as dictionaries.'''
    return conn.cursor(pymysql.cursors.DictCursor)

if __name__ == '__main__':
    print('starting test code')
    import sys
    if len(sys.argv) < 2:
        print('''Usage: {cmd} cnf_file
test dbconn by giving the name of a cnf_file on the command line'''
              .format(cmd=sys.argv[0]))
        sys.exit(1)
    cnf_file = sys.argv[1]
    conn = connect_again(cnf_file,'wmdb')
    print('successfully connected')
    curs = cursor(conn)
    curs.execute('select user() as user, database() as db')
    row = curs.fetchone()
    print('connected to {db} as {user}'
          .format(db=row[1],user=row[0]))
    curs = dictCursor(conn)
    curs.execute('select nm,name,birthdate from person limit 3')
    print('first three people')
    for row in curs.fetchall():
        print('{} ({}) born {}'.format(row['name'],row['nm'],row['birthdate']))
    curs.execute('select nm,name,birthdate from person where name like %s',
                 ['%george%'])
    print('names like george')
    for row in curs.fetchall():
        print('{} ({}) born {}'.format(row['name'],row['nm'],row['birthdate']))
    print('test exception handling by inserting an existing NM value')
    try:
        curs.execute('''insert into person(nm,name)
                        values(123,'not George Clooney');''')
    except pymysql.err.IntegrityError as err:
        print('IntegrityError: {}'.format(repr(err)))

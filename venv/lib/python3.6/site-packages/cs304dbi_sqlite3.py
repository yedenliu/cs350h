'''Module intended to mimic the cs304dbi module but working with sqlite3
instead of PyMySQL.

In this module, DSN stands for "Data Source Name"

How to use this:

import cs304dbi_sqlite3 as dbi

Invoking read_cnf() or cache_cnf() is optional and ignored, because SQLite
doesn't do authentication.

conn = dbi.connect(dsn)
conn.select_db('wmdb')

Use the DSN (credentials dictionary) to connect to the database. From here
on, mostly use the Python DB-API

conn = dbi.connect(dsn)
conn.select_db('wmdb')
curs = db.dict_cursor(conn)
curs.execute('select name,birthdate from person')
curs.execute('select name,birthdate from person where name like %s',
             ['%george%'])
curs.fetchall()
curs.fetchone()

'''

import sqlite3
import configparser
import os

# got this code from pymsql/optionfile.py

class Parser(configparser.RawConfigParser):

    def __remove_quotes(self, value):
        quotes = ["'", "\""]
        for quote in quotes:
            if len(value) >= 2 and value[0] == value[-1] == quote:
                return value[1:-1]
        return value

    def get(self, section, option):
        value = configparser.RawConfigParser.get(self, section, option)
        return self.__remove_quotes(value)

def read_cnf(cnf_file='~/.my.cnf'):
    '''Read a file formatted like ~/.my.cnf file; defaulting to that
    file. Return a dictionary with the necessary information to connect to
    a database. See the connect() function.'''
    abs_cnf_file = os.path.expanduser(cnf_file)
    if not os.path.exists(abs_cnf_file):
        raise FileNotFoundError(cnf_file)

    # this code is from pymysql/connections.py
    read_default_group = "client"
    cfg = Parser()
    cfg.read(abs_cnf_file)

    def _config(key):
        return cfg.get(read_default_group, key)

    user = _config("user")
    password = _config("password")
    host = _config("host")
    # on Tempest, we put the database in the mysql group
    database = cfg.get("mysql","database")
    return {'user': user,
            'password': password,
            'host': host,
            'database': database}

DSN_CACHE = None

def cache_cnf(cnf_file='~/.my.cnf'):
    '''Like read_cnf but reads the CNF file only once and caches the results'''
    global DSN_CACHE
    if DSN_CACHE is None:
        DSN_CACHE = dict()
    return DSN_CACHE

def use(database):
    '''Like the 'use' statement, but modifies the cached cnf. Then connect()'''
    global DSN_CACHE
    if DSN_CACHE is None:
        DSN_CACHE = dict()
    DSN_CACHE['database'] = database

def connect(dsn=cache_cnf('~/.my.cnf')):
    '''Returns a new database connection given the dsn (a dictionary). The
default is to use cache_cnf('~/.my.cnf')

    The database connection is not set to automatically commit.

    '''
    try:
        conn = sqlite3.connect(DSN_CACHE['database']+'.db')
    except sqlite3.Error as e:
        print("Couldn't connect to database. SQLite3 error {}: {}"
              .format(e.args[0], e.args[1]))
        raise
    return conn

def check_DSN(dsn):
    '''Raises a comprehensible error message if the DSN is missing
    some necessary info'''
    for key in ('database' ):
        if not key in dsn:
            raise KeyError('''DSN lacks necessary '{k}' key'''.format(k=key))
    return True

def select_db(conn,db):
    '''This function isn't necessary; just use the select_db() method
on the connection.'''
    raise Exception('cannot select a different database in SQLite3')

def cursor(conn):
    '''Returns a cursor where rows are represented as tuples.'''
    return conn.cursor()

# Follows this
# https://docs.python.org/3/library/sqlite3.html#accessing-columns-by-name-instead-of-by-index

def dict_factory(cursor, row):
    d = {}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d

def dict_cursor(conn):
    '''Returns a cursor where rows are represented as dictionaries.'''
    conn.row_factory = dict_factory
    return conn.cursor()

def _testing_changed_cache(cnf_file):
    '''Testing that changing the db in the cache changes future connections'''
    # checking modification of DSN. But students can't switch to scottdb, so
    # this is just for scott
    scottdsn = cache_cnf(cnf_file)
    # we will use scottdb from now on
    scottdsn['database'] = 'scottdb'
    conn2 = connect()           # don't even have to supply it as an argment
    curs2 = cursor(conn2)
    curs2.execute('select database()')
    db = curs2.fetchone()[0]
    if db == 'scottdb':
        print('Successfully changed the database to scottdb')
    else:
        raise Error('did not successfully change database')
    return conn2

def _testing_commit(cnf_file):
    '''For Scott to test the behavior of commit()'''
    def drevil(should_be_there):
        conn = connect()
        curs = conn.cursor()
        curs.execute('select database()')
        db = curs.fetchone()[0]
        if db != 'scottdb':
            raise Exception('did not connect to scottdb')
        curs.execute('select name from person where nm = 666')
        row = curs.fetchone()
        name = None if row is None else row[0]
        if should_be_there and name is None:
            raise Exception('name is not there and it should be there')
        else:
            print('name is correctly there')
        if not should_be_there and name is not None:
            raise Exception('name is there and it should not be there')
        else:
            print('name is correctly not there')

    # series of checks about behavior of commit
    conn2 = _testing_changed_cache(cnf_file)
    curs2 = conn2.cursor()
    # set up by removing dr evil
    curs2.execute('delete from person where nm = 666')
    conn2.commit()
    # it should not be there
    drevil(False)

    # since autocommit is false, this won't stick
    curs2.execute('''insert into person(nm,name) values(666, 'dr evil')
                     on duplicate key update name='dr evil' ''')
    drevil(False)

    # now, commit the insert/update in connection 2
    conn2.commit()
    drevil(True)

    # clean up by removing dr evil
    curs2.execute('delete from person where nm = 666')
    conn2.commit()
    # last check, to make sure it's gone
    drevil(False)


if __name__ == '__main__':
    print('starting test code')
    import sys
    import os
    if len(sys.argv) < 2:
        print('''Usage: {cmd} cnf_file
test dbconn by giving the name of a cnf_file on the command line'''
              .format(cmd=sys.argv[0]))
        sys.exit(1)
    cnf_file = sys.argv[1]
    DSN = cache_cnf(cnf_file)
    use('wmdb2')
    conn = connect()
    curs = cursor(conn)
    curs.execute('select count(*) from person')
    row = curs.fetchone()
    print('wmdb2 has {} rows in the person table'.format(row[0]))
    curs = dict_cursor(conn)
    # example of a simple query
    curs.execute('select nm,name,birthdate from person limit 3')
    print('first three people')
    for row in curs.fetchall():
        print(row)
    # example of a prepared query
    curs.execute('select nm,name,birthdate from person where name like ?',
                 ['%george%'])
    print('names like george')
    for row in curs.fetchall():
        print(row)

